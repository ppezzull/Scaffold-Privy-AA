# Nitrolite Protocol Specification

## 1. Introduction

This document specifies the Nitrolite state channel protocol, a system that enables off-chain interactions between participants with minimal on-chain operations. This specification defines the data structures, message formats, and protocol rules.

Nitrolite protocol is a chain-agnostic protocol and form a unified virtual ledger (called `clearnet`) for Application to escrow funds while being
fully abstract from the underlying blockchain used.

The initial version of nitrolite is EVM compatible and will be deployed on most L1/L2.

## 2. Terminology

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

- **Channel**: A secure communication pathway between participants
- **State**: A snapshot of the channel at a point in time
- **Adjudicator**: A contract that validates state transitions
- **stateHash**: A cryptographic hash of a channel state
- **Creator**: Most often a light client willing to fund a ledger account with `broker`
- **Broker**: A RPC Message Broker responsible of creating virtual ledger channels

## 3. Data Structures

### 3.1. Channel

```solidity
struct Channel {
    address[] participants; // List of participants in the channel
    address adjudicator;    // Contract that validates state transitions
    uint64 challenge;       // Duration in seconds for dispute resolution
    uint64 nonce;           // Unique identifier for channels
}
```

### 3.2. State

```solidity
struct State {
    bytes data;           // Application-specific data
    Allocation[] allocations; // Asset allocation for each participant
    Signature[] sigs;     // Signatures from participants
}
```

### 3.3. Allocation

```solidity
struct Allocation {
    address destination; // Recipient of funds
    address token;       // ERC-20 token address
    uint256 amount;      // Token amount
}
```

### 3.4. Signature

```solidity
struct Signature {
    uint8 v;
    bytes32 r;
    bytes32 s;
}
```

### 3.5. Amount

```solidity
struct Amount {
    address token;   // ERC-20 token address
    uint256 amount;  // Token amount
}
```

### 3.6. Channel Status

```solidity
enum Status {
    VOID,     // Channel not created
    INITIAL,  // Creation in progress
    ACTIVE,   // Fully funded and operational
    DISPUTE,  // Challenge period active
    FINAL     // Ready to be closed
}
```

### 3.7. Protocol Constants

```solidity
constant uint256 CREATOR = 0; // Creator's participant index
constant uint256 BROKER = 1;  // Broker's participant index only in clearnet context
constant uint32 CHANOPEN = 7877;  // Magic number for funding state
constant uint32 CHANCLOSE = 7879; // Magic number for closing state
```

## 4. Identifier Computation

### 4.1. Channel Identifier

The channelId MUST be computed as:

```solidity
channelId = keccak256(
    abi.encode(
        ch.participants,
        ch.adjudicator,
        ch.challenge,
        ch.nonce
    )
);
```

Virtual Ledger Channels (VLC) identifier are computed in the same way.

### 4.2. State Hash

The stateHash MUST be computed as:

```solidity
stateHash = keccak256(
    abi.encode(
        channelId,
        state.data,
        state.allocations
    )
);
```

For signature verification, the stateHash is bare signed without EIP-191 since the protocol is intended to be chain-agnostic.

## 5. Funding Protocol

IMPORTANT: Contract caller usually (EOA) are usually different than participant public address.
Participants are derived and generated by the owner similarly to session keys. The main reason is
for User Experience and high frequency state signing.

Funding protocol define a specific State with magic number that must be used for creating and closing channels.
Once the channel status is `ACTIVE` the Application protocol takes over off-chain and the specified Adjudicator
regulate the Application protocol instead of Funding Protocol.

### 5.1. Creation Phase

1. The Creator MUST:
   - Construct a channel configuration with participants, adjudicator, challenge period, and nonce
   - Prepare an initial state where `state.data` MUST be set to the magic number `CHANOPEN` (7877)
   - Define expected token deposits for all participants in the `state.allocations` array
   - Compute the Funding stateHash of this initial deposit state
   - Include creator stateHash signature in the `state.sigs` array at position 0
   - Call the `create` function with the channel configuration and initial signed state

2. The system MUST:
   - Verify the Creator's signature on the funding stateHash
   - creator have sufficient balance to fund his required allocation
   - Lock the Creator's funds according to the allocation
   - Set the channel status to `INITIAL`
   - Emit a `Created` event with the channelId, channel configuration, and expected deposits

### 5.2. Joining Phase

1. Each non-Creator participant MUST:
   - Verify the channelId and expected allocations
   - Sign the same funding stateHash (containing the magic number `CHANOPEN`)
   - Call the `join` function with the channelId, their participant index, and signature

2. The system MUST:
   - Verify the participant's signature against the funding stateHash
   - Confirm the signer matches the expected participant at the given index
   - Lock the participant's funds according to the allocation
   - Track the actual deposit in the channel metadata
   - Emit a `Joined` event with the channelId and participant index

3. When all participants have joined, the system MUST:
   - Verify that all expected deposits are fulfilled
   - Set the channel status to `ACTIVE`
   - Emit an `Opened` event with the channelId

## 6. Off-Chain State Updates

1. Participants MUST:
   - Exchange and sign state updates off-chain
   - Maintain a record of the latest valid state
   - Signatures can be signing different states Adjudicator is free to define protocol.
   - Use application-specific data in the `state.data` field

2. Each new state MUST:
   - Contain updated allocations reflecting the new distribution of assets
   - Be signed by the necessary participants according to application rules
   - Comply with the validation rules of the channel's adjudicator

## 7. Channel Closure

### 7.1. Cooperative Close

1. To close cooperatively, any participant MAY:
   - Prepare a final state where `state.data` MUST be set to the magic number `CHANCLOSE` (7879)
   - Collect signatures from all participants on this final state
   - Call the `close` function with the channelId, final state, and any required proofs

2. The system MUST:
   - Verify all participant signatures on the closing stateHash
   - Verify the state contains the `CHANCLOSE` magic number
   - Distribute funds according to the final state's allocations
   - Set the channel status to `FINAL`
   - Delete the channel and emit a `Closed` event

### 7.2. Challenge-Response Process

1. To initiate a challenge, a participant MAY:
   - Call the `challenge` function with their latest valid state and required proofs

2. The system MUST:
   - Verify the submitted state via the adjudicator
   - If valid, store the state and start the challenge period
   - Set a challenge expiration timestamp (current time + challenge duration)
   - Set the channel status to `DISPUTE`
   - Emit a `Challenged` event with the channelId and expiration time

3. During the challenge period, any participant MAY:
   - Submit a more recent valid state by calling `challenge` again
   - If the new state is valid and more recent (as determined by the adjudicator or `IComparable`), the system MUST update the stored state and reset the challenge period

4. After the challenge period expires, any participant MAY call `close` to distribute funds according to the last valid challenged state

### 7.3. Checkpointing

1. Any participant MAY:
   - Call the `checkpoint` function with a valid state and required proofs

2. The system MUST:
   - Verify the submitted state via the adjudicator
   - If valid, and more recent store the state without starting a challenge period
   - Emit a `Checkpointed` event with the channelId

## 8. Reset Protocol

1. To reset a channel (for resizing allocations), any participant MAY:
   - Call the `reset` function with:
     - The current channelId
     - A valid closing state with all signatures
     - Any required proofs
     - A new channel configuration
     - A new initial state with the `CHANOPEN` magic number

2. The system MUST:
   - Close the existing channel as per the cooperative close process
   - Create a new channel following the creation process
   - Return the new channelId

## 9. Security Considerations

1. All state updates MUST be signed by the relevant participants
2. The challenge period MUST be sufficiently long to allow participants to respond
3. The adjudicator MUST validate all state transitions according to application-specific rules
4. Funds MUST only be distributed according to mutually agreed allocations
