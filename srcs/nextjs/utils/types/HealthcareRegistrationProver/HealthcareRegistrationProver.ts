/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type SealStruct = {
  verifierSelector: BytesLike;
  seal: BytesLike[];
  mode: BigNumberish;
};

export type SealStructOutput = [
  verifierSelector: string,
  seal: string[],
  mode: bigint
] & { verifierSelector: string; seal: string[]; mode: bigint };

export type CallAssumptionsStruct = {
  proverContractAddress: AddressLike;
  functionSelector: BytesLike;
  settleChainId: BigNumberish;
  settleBlockNumber: BigNumberish;
  settleBlockHash: BytesLike;
};

export type CallAssumptionsStructOutput = [
  proverContractAddress: string,
  functionSelector: string,
  settleChainId: bigint,
  settleBlockNumber: bigint,
  settleBlockHash: string
] & {
  proverContractAddress: string;
  functionSelector: string;
  settleChainId: bigint;
  settleBlockNumber: bigint;
  settleBlockHash: string;
};

export type ProofStruct = {
  seal: SealStruct;
  callGuestId: BytesLike;
  length: BigNumberish;
  callAssumptions: CallAssumptionsStruct;
};

export type ProofStructOutput = [
  seal: SealStructOutput,
  callGuestId: string,
  length: bigint,
  callAssumptions: CallAssumptionsStructOutput
] & {
  seal: SealStructOutput;
  callGuestId: string;
  length: bigint;
  callAssumptions: CallAssumptionsStructOutput;
};

export type DnsRecordStruct = {
  name: string;
  recordType: BigNumberish;
  data: string;
  ttl: BigNumberish;
};

export type DnsRecordStructOutput = [
  name: string,
  recordType: bigint,
  data: string,
  ttl: bigint
] & { name: string; recordType: bigint; data: string; ttl: bigint };

export type VerificationDataStruct = {
  validUntil: BigNumberish;
  signature: BytesLike;
  pubKey: BytesLike;
};

export type VerificationDataStructOutput = [
  validUntil: bigint,
  signature: string,
  pubKey: string
] & { validUntil: bigint; signature: string; pubKey: string };

export type UnverifiedEmailStruct = {
  email: string;
  dnsRecord: DnsRecordStruct;
  verificationData: VerificationDataStruct;
};

export type UnverifiedEmailStructOutput = [
  email: string,
  dnsRecord: DnsRecordStructOutput,
  verificationData: VerificationDataStructOutput
] & {
  email: string;
  dnsRecord: DnsRecordStructOutput;
  verificationData: VerificationDataStructOutput;
};

export declare namespace HealthcareRegistrationProver {
  export type RegistrationDataStruct = {
    requestedRole: BigNumberish;
    walletAddress: AddressLike;
    domain: string;
    organizationName: string;
    emailHash: BytesLike;
  };

  export type RegistrationDataStructOutput = [
    requestedRole: bigint,
    walletAddress: string,
    domain: string,
    organizationName: string,
    emailHash: string
  ] & {
    requestedRole: bigint;
    walletAddress: string;
    domain: string;
    organizationName: string;
    emailHash: string;
  };
}

export interface HealthcareRegistrationProverInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "proof"
      | "proveOrganizationDomain"
      | "provePatientEmail"
      | "setBlock"
      | "setChain"
      | "stringToAddress"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "proof", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proveOrganizationDomain",
    values: [UnverifiedEmailStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "provePatientEmail",
    values: [UnverifiedEmailStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlock",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setChain",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stringToAddress",
    values: [string]
  ): string;

  decodeFunctionResult(functionFragment: "proof", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proveOrganizationDomain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "provePatientEmail",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setBlock", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setChain", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stringToAddress",
    data: BytesLike
  ): Result;
}

export interface HealthcareRegistrationProver extends BaseContract {
  connect(runner?: ContractRunner | null): HealthcareRegistrationProver;
  waitForDeployment(): Promise<this>;

  interface: HealthcareRegistrationProverInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  proof: TypedContractMethod<[], [ProofStructOutput], "view">;

  proveOrganizationDomain: TypedContractMethod<
    [unverifiedEmail: UnverifiedEmailStruct],
    [
      [
        ProofStructOutput,
        HealthcareRegistrationProver.RegistrationDataStructOutput
      ]
    ],
    "view"
  >;

  provePatientEmail: TypedContractMethod<
    [unverifiedEmail: UnverifiedEmailStruct],
    [
      [
        ProofStructOutput,
        HealthcareRegistrationProver.RegistrationDataStructOutput
      ]
    ],
    "view"
  >;

  setBlock: TypedContractMethod<[blockNo: BigNumberish], [void], "nonpayable">;

  setChain: TypedContractMethod<
    [chainId: BigNumberish, blockNo: BigNumberish],
    [void],
    "nonpayable"
  >;

  stringToAddress: TypedContractMethod<[str: string], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "proof"
  ): TypedContractMethod<[], [ProofStructOutput], "view">;
  getFunction(
    nameOrSignature: "proveOrganizationDomain"
  ): TypedContractMethod<
    [unverifiedEmail: UnverifiedEmailStruct],
    [
      [
        ProofStructOutput,
        HealthcareRegistrationProver.RegistrationDataStructOutput
      ]
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "provePatientEmail"
  ): TypedContractMethod<
    [unverifiedEmail: UnverifiedEmailStruct],
    [
      [
        ProofStructOutput,
        HealthcareRegistrationProver.RegistrationDataStructOutput
      ]
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "setBlock"
  ): TypedContractMethod<[blockNo: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setChain"
  ): TypedContractMethod<
    [chainId: BigNumberish, blockNo: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "stringToAddress"
  ): TypedContractMethod<[str: string], [string], "view">;

  filters: {};
}
